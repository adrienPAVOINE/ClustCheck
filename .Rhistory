#' @return an object returning a list of active data (categorical and numerical data), number of samples, etc.
#' @export
#' @importFrom grDevices rainbow
#' @importFrom stats dist reshape
#' @import questionr
#' @import factoextra
#' @import ggplot2
#' @examples
Dataset <- function(data,vargroupe){
#If the Cluster vector is not a factor
vargroupe <- factor(vargroupe)
#concatenate the vector and the data
allData <- cbind(groupe = vargroupe, data)
#if the vector is already in the data, we remove it
data <- data.frame(allData[,colnames(unique(as.matrix(allData), MARGIN=2))])
#extract all the active variables (1 is always the cluster group)
dataexp <- data[,-1]
instance <- list()
instance$dataexp <- dataexp  #data of all the active variables
instance$clusters_data = vargroupe #data of the cluster vector
instance$data <- data #all the data
instance$p <- ncol(data) #number of variables
instance$n <- nrow(data) #number of samples-
instance$cluster_names <- unique(vargroupe) #group names in the cluster vector
#controle - data.frame
ok <- is.data.frame(data) #check if the dataset is a dataframe
if (!ok){
stop("The data is not in a dataframe format")
}
ind.qual <- sapply(dataexp,function(x)is.factor(x)|is.character(x)) #To get all the categorical variables data
nb_qual <- sum(ind.qual)
ind.qual1 <- sapply(data,function(x)is.factor(x)|is.character(x)) #To get all the categorical variables including the vector of cluster data
data.qual1 <- data[ ,ind.qual1]
#CheckVarQual <- TRUE
#To know if there is categorical variable (for the metrics functions)
if (nb_qual < 1 ){
#print("There are no categorical variables in your dataset")
#CheckVarQual <- FALSE
}else{
data.qual <- dataexp[ ,ind.qual] #the data of the categorical variables
instance$p.qual <- ncol(data.qual) #number of categorical variables
instance$all.var.qual <- data.qual1 #the data of the categorical variables including the vector of cluster data
instance$var.qual.names <- names(data.qual) #names of the categorical variables
instance$data.qual <- data.qual
instance$ind.qual <- ind.qual
instance$vcramer <- Vcramer.Data(instance) #return the cramer V value for all the category variables
}
ind.quanti = sapply(dataexp,function(x)is.numeric(x)|is.double(x))#To get all the numerical variables data
nb_quanti <- sum(ind.quanti)
if (nb_quanti < 1 ){
#print("There are no numerical variables in your dataset")
}else{
data.quanti <- dataexp[ ,ind.quanti]#the data of the numerical variables
instance$data.quanti <- data.quanti
instance$p.quanti <- ncol(data.quanti) #number of numerical variables
instance$var.quanti.names <- names(data.quanti) #names of the numerical variables
instance$ind.quanti <- ind.quanti #index of the numerical variables
instance$corr.ratio <- Corr_ratios.Data(instance)#return the corr ratio values for all the numerical variables
}
if (nb_qual>0){
if (nb_quanti>0){
Vartype <- "MIX"
}else{
Vartype <- "CAT"
}
}else{
Vartype <- "NUM"
}
instance$Vartype <- Vartype
cat("Class correctly instanciated.","\n")
cat("The dataset contains ",nb_qual," categorical variables and ",nb_quanti," numerical variables.")
class(instance) <- "Data" #Creation of the data object
return(instance) #returns all instance parameters
}
newoj <- Dataset(data, data$Cluster)
silhouette.Data(newoj,data$Cluster)
#' @examples
#' Transformdata.Data
#'
#' @param object a data object
#'
#' @return
#' @export
#'
#' @examples
Transformdata.Data <- function(object){
# #fonction pour centrage-réduction
# CR <- function(x){
#   n <- length(x)
#   m <- mean(x)
#   v <- (n-1)/n*var(x)
#   return((x-m)/sqrt(v))
# }
# #appliquer la fonction sur les variables continues
# varcont <- data.frame(lapply(subset(object$dataexp,select=object$ind.quanti),CR))
# #codage disjonctif complet
# #library(ade4)
# varquali <- ade4::acm.disjonctif(subset(object$dataexp,select=object$ind.qual))
# #fonction pour pondération des indicatrices
# PF <- function(x){
#   m <- mean(x)
#   return(x/sqrt(m))
# }
# #appliquer la pondération sur les indicatrices
# varquali.pond <- data.frame(lapply(varquali,PF))
# #données transformées envoyées ?l'ACP
# data.pour.acp <- cbind(varcont,varquali.pond)
# nbcol.tot <- ncol(data.pour.acp)
# print(nbcol.tot)
# rownames(data.pour.acp) <- rownames(object$data)
res.famd <- FAMD(object$dataexp, graph = FALSE)
ind <- get_famd_ind(res.famd)
return(ind$coord)
#
#
# acp.data <- ade4::dudi.pca(data.pour.acp,center=T,scale=F,scannf=F, nf=nbcol.tot)
# coordind = round(acp.data$li[,])
# ind <-cbind(coordind)
}
# ------------------------------------------------------------------------- #
#' silhouette.Data
#'
#' @param object a datset object
#' @param Clusters a vector cluster
#'
#' @return
#' @export
#'
#' @examples
silhouette.Data <- function(object, Clusters) {
print(object$Vartype)
if(object$Vartype== "CAT" | object$Vartype == "MIX"){
data <- Transformdata.Data(object)
}else{
data <- object$dataexp
}
print(data)
# a: The mean distance between a sample and all other points in the same class.
# b: The mean distance between a sample and all other points in the next nearest cluster.
if (nrow(data)!=length(Clusters)){
stop("Feature data and cluster data don't have the same length")
}
d <- as.matrix(dist(data))
n <- ncol(d)
a <- NULL; b <- NULL
for (col in 1:n){
cluster <- Clusters[col]
# calculation for a
same_class <- which(Clusters==cluster) # identification of the class samples
same_class_wo_sample <- same_class[which(same_class!=col)] # we remove the sample here
a <- c(a,mean(d[same_class_wo_sample,col]))
# calculation for b
all_different_class <- which(Clusters!=cluster) # identification of all the other samples
w <- as.integer(names(which.min(d[all_different_class,col]))) # identification of the closest sample in an other sample
nearest_cluster <- Clusters[w] # identification of the next nearest cluster
different_class <- which(Clusters==nearest_cluster)
b <- c(b,mean(d[different_class,col]))
}
s <- (b - a)/pmax(a,b) # silhouette formula
for (k in unique(Clusters)){
ind = which(Clusters == k)
nbk <- sum(Clusters == k)
sk <- 1/nbk * (sum(s[ind]))
cat("Silhouette du groupe" , k )
print(sk)
}
return(mean(s))
}
silhouette.Data(newoj,data$Cluster)
#' Transformdata.Data
#'
#' @param object a data object
#'
#' @return
#' @export
#' @import FactoMineR
#' @import factoextra
#'
#' @examples
Transformdata.Data <- function(object){
# #fonction pour centrage-réduction
# CR <- function(x){
#   n <- length(x)
#   m <- mean(x)
#   v <- (n-1)/n*var(x)
#   return((x-m)/sqrt(v))
# }
# #appliquer la fonction sur les variables continues
# varcont <- data.frame(lapply(subset(object$dataexp,select=object$ind.quanti),CR))
# #codage disjonctif complet
# #library(ade4)
# varquali <- ade4::acm.disjonctif(subset(object$dataexp,select=object$ind.qual))
# #fonction pour pondération des indicatrices
# PF <- function(x){
#   m <- mean(x)
#   return(x/sqrt(m))
# }
# #appliquer la pondération sur les indicatrices
# varquali.pond <- data.frame(lapply(varquali,PF))
# #données transformées envoyées ?l'ACP
# data.pour.acp <- cbind(varcont,varquali.pond)
# nbcol.tot <- ncol(data.pour.acp)
# print(nbcol.tot)
# rownames(data.pour.acp) <- rownames(object$data)
res.famd <- FAMD(object$dataexp, graph = FALSE)
ind <- get_famd_ind(res.famd)
return(ind$coord)
#
#
# acp.data <- ade4::dudi.pca(data.pour.acp,center=T,scale=F,scannf=F, nf=nbcol.tot)
# coordind = round(acp.data$li[,])
# ind <-cbind(coordind)
}
# ------------------------------------------------------------------------- #
#' silhouette.Data
#'
#' @param object a datset object
#' @param Clusters a vector cluster
#'
#' @return
#' @export
#'
#' @examples
silhouette.Data <- function(object, Clusters) {
print(object$Vartype)
if(object$Vartype== "CAT" | object$Vartype == "MIX"){
data <- Transformdata.Data(object)
}else{
data <- object$dataexp
}
print(data)
# a: The mean distance between a sample and all other points in the same class.
# b: The mean distance between a sample and all other points in the next nearest cluster.
if (nrow(data)!=length(Clusters)){
stop("Feature data and cluster data don't have the same length")
}
d <- as.matrix(dist(data))
n <- ncol(d)
a <- NULL; b <- NULL
for (col in 1:n){
cluster <- Clusters[col]
# calculation for a
same_class <- which(Clusters==cluster) # identification of the class samples
same_class_wo_sample <- same_class[which(same_class!=col)] # we remove the sample here
a <- c(a,mean(d[same_class_wo_sample,col]))
# calculation for b
all_different_class <- which(Clusters!=cluster) # identification of all the other samples
w <- as.integer(names(which.min(d[all_different_class,col]))) # identification of the closest sample in an other sample
nearest_cluster <- Clusters[w] # identification of the next nearest cluster
different_class <- which(Clusters==nearest_cluster)
b <- c(b,mean(d[different_class,col]))
}
s <- (b - a)/pmax(a,b) # silhouette formula
for (k in unique(Clusters)){
ind = which(Clusters == k)
nbk <- sum(Clusters == k)
sk <- 1/nbk * (sum(s[ind]))
cat("Silhouette du groupe" , k )
print(sk)
}
return(mean(s))
}
silhouette.Data(newoj,data$Cluster)
#' Transformdata.Data
#'
#' @param object a data object
#'
#' @return
#' @export
#' @import FactoMineR
#' @import factoextra
#'
#' @examples
Transformdata.Data <- function(object){
# #fonction pour centrage-réduction
# CR <- function(x){
#   n <- length(x)
#   m <- mean(x)
#   v <- (n-1)/n*var(x)
#   return((x-m)/sqrt(v))
# }
# #appliquer la fonction sur les variables continues
# varcont <- data.frame(lapply(subset(object$dataexp,select=object$ind.quanti),CR))
# #codage disjonctif complet
# #library(ade4)
# varquali <- ade4::acm.disjonctif(subset(object$dataexp,select=object$ind.qual))
# #fonction pour pondération des indicatrices
# PF <- function(x){
#   m <- mean(x)
#   return(x/sqrt(m))
# }
# #appliquer la pondération sur les indicatrices
# varquali.pond <- data.frame(lapply(varquali,PF))
# #données transformées envoyées ?l'ACP
# data.pour.acp <- cbind(varcont,varquali.pond)
# nbcol.tot <- ncol(data.pour.acp)
# print(nbcol.tot)
# rownames(data.pour.acp) <- rownames(object$data)
res.famd <- FactoMineR::FAMD(object$dataexp, graph = FALSE)
ind <- get_famd_ind(res.famd)
return(ind$coord)
#
#
# acp.data <- ade4::dudi.pca(data.pour.acp,center=T,scale=F,scannf=F, nf=nbcol.tot)
# coordind = round(acp.data$li[,])
# ind <-cbind(coordind)
}
silhouette.Data(newoj,data$Cluster)
#' Transformdata.Data
#'
#' @param object a data object
#'
#' @return
#' @export
#' @import FactoMineR
#' @import factoextra
#'
#' @examples
Transformdata.Data <- function(object){
# #fonction pour centrage-réduction
# CR <- function(x){
#   n <- length(x)
#   m <- mean(x)
#   v <- (n-1)/n*var(x)
#   return((x-m)/sqrt(v))
# }
# #appliquer la fonction sur les variables continues
# varcont <- data.frame(lapply(subset(object$dataexp,select=object$ind.quanti),CR))
# #codage disjonctif complet
# #library(ade4)
# varquali <- ade4::acm.disjonctif(subset(object$dataexp,select=object$ind.qual))
# #fonction pour pondération des indicatrices
# PF <- function(x){
#   m <- mean(x)
#   return(x/sqrt(m))
# }
# #appliquer la pondération sur les indicatrices
# varquali.pond <- data.frame(lapply(varquali,PF))
# #données transformées envoyées ?l'ACP
# data.pour.acp <- cbind(varcont,varquali.pond)
# nbcol.tot <- ncol(data.pour.acp)
# print(nbcol.tot)
# rownames(data.pour.acp) <- rownames(object$data)
res.famd <- FactoMineR::FAMD(object$dataexp, graph = FALSE)
ind <- FactoMineR::get_famd_ind(res.famd)
return(ind$coord)
#
#
# acp.data <- ade4::dudi.pca(data.pour.acp,center=T,scale=F,scannf=F, nf=nbcol.tot)
# coordind = round(acp.data$li[,])
# ind <-cbind(coordind)
}
silhouette.Data(newoj,data$Cluster)
#' Transformdata.Data
#'
#' @param object a data object
#'
#' @return
#' @export
#' @import FactoMineR
#' @import factoextra
#'
#' @examples
Transformdata.Data <- function(object){
# #fonction pour centrage-réduction
# CR <- function(x){
#   n <- length(x)
#   m <- mean(x)
#   v <- (n-1)/n*var(x)
#   return((x-m)/sqrt(v))
# }
# #appliquer la fonction sur les variables continues
# varcont <- data.frame(lapply(subset(object$dataexp,select=object$ind.quanti),CR))
# #codage disjonctif complet
# #library(ade4)
# varquali <- ade4::acm.disjonctif(subset(object$dataexp,select=object$ind.qual))
# #fonction pour pondération des indicatrices
# PF <- function(x){
#   m <- mean(x)
#   return(x/sqrt(m))
# }
# #appliquer la pondération sur les indicatrices
# varquali.pond <- data.frame(lapply(varquali,PF))
# #données transformées envoyées ?l'ACP
# data.pour.acp <- cbind(varcont,varquali.pond)
# nbcol.tot <- ncol(data.pour.acp)
# print(nbcol.tot)
# rownames(data.pour.acp) <- rownames(object$data)
res.famd <- FactoMineR::FAMD(object$dataexp, graph = FALSE)
ind <- factoextra::get_famd_ind(res.famd)
return(ind$coord)
#
#
# acp.data <- ade4::dudi.pca(data.pour.acp,center=T,scale=F,scannf=F, nf=nbcol.tot)
# coordind = round(acp.data$li[,])
# ind <-cbind(coordind)
}
silhouette.Data(newoj,data$Cluster)
davies_bouldin <- function(data, clusters) {
k <- length(unique(clusters))
p <- ncol(data)
centroids <- matrix(nrow=k, ncol=p)
d <- matrix(nrow=k, ncol=k)
s <- matrix(nrow=1, ncol=k)
R <- matrix(nrow=k, ncol=k)
maxR <- matrix(nrow=1, ncol=k)
# Centroids calculation
i=1
for (g in unique(clusters)){
k_data <- data[which(clusters==g),]
centroids[i,] <- sapply(k_data, mean, na.rm=T)
s[i] <- sqrt(mean(rowSums(apply(k_data, 2, function(y) (y - mean(y))^2))))
i = i+1
}
# R and d calculation
for (i in 1:k){
for (j in 1:k){
d[i,j] <- sqrt(sum((centroids[i,] - centroids[j,])^2))
R[i,j] <- (s[i]+s[j])/d[i,j]
}
}
# Index calculation
for (i in 1:k){
maxR[i] <- max(R[i,][is.finite(R[i,])])
}
DB <- sum(maxR)/k
return(DB)
}
davies_bouldin <- function(object, clusters) {
k <- length(unique(clusters))
p <- object$p
centroids <- matrix(nrow=k, ncol=p)
d <- matrix(nrow=k, ncol=k)
s <- matrix(nrow=1, ncol=k)
R <- matrix(nrow=k, ncol=k)
maxR <- matrix(nrow=1, ncol=k)
# Centroids calculation
i=1
for (g in unique(clusters)){
k_data <- object$dataexp[which(clusters==g),]
centroids[i,] <- sapply(k_data, mean, na.rm=T)
s[i] <- sqrt(mean(rowSums(apply(k_data, 2, function(y) (y - mean(y))^2))))
i = i+1
}
# R and d calculation
for (i in 1:k){
for (j in 1:k){
d[i,j] <- sqrt(sum((centroids[i,] - centroids[j,])^2))
R[i,j] <- (s[i]+s[j])/d[i,j]
}
}
# Index calculation
for (i in 1:k){
maxR[i] <- max(R[i,][is.finite(R[i,])])
}
DB <- sum(maxR)/k
return(DB)
}
davies_bouldin(newoj, data$Cluster)
davies_bouldin(newoj$data.quanti, data$Cluster)
newoj$data.quanti
davies_bouldin <- function(data, clusters) {
k <- length(unique(clusters))
p <- ncol(data)
centroids <- matrix(nrow=k, ncol=p)
d <- matrix(nrow=k, ncol=k)
s <- matrix(nrow=1, ncol=k)
R <- matrix(nrow=k, ncol=k)
maxR <- matrix(nrow=1, ncol=k)
# Centroids calculation
i=1
for (g in unique(clusters)){
k_data <- data[which(clusters==g),]
centroids[i,] <- sapply(k_data, mean, na.rm=T)
s[i] <- sqrt(mean(rowSums(apply(k_data, 2, function(y) (y - mean(y))^2))))
i = i+1
}
# R and d calculation
for (i in 1:k){
for (j in 1:k){
d[i,j] <- sqrt(sum((centroids[i,] - centroids[j,])^2))
R[i,j] <- (s[i]+s[j])/d[i,j]
}
}
# Index calculation
for (i in 1:k){
maxR[i] <- max(R[i,][is.finite(R[i,])])
}
DB <- sum(maxR)/k
return(DB)
}
davies_bouldin(newoj$data.quanti, data$Cluster)
#' CalcTable.Data
#'
#' @param object a Dataset object
#' @param varqual the other variable to cross
#'
#' @return
#' @export
#' @importFrom stats addmargins
#' @examples
CalcTable.Data <- function(object, varqual){
#creation of the cross table between the cluster data and an other category variable
tableau <- table(object$clusters_data,varqual)
nli <- nrow(tableau) #number of cluster
nco <- ncol(tableau) #number of modality in the other category variable
eff <- addmargins(tableau) #to add Sum and names of the modalities
pourc <- addmargins(prop.table(addmargins(tableau,1),1),2) #prop.table to have the percentage by lines
return(list(tableau, eff, pourc, nco, nli))
}
CalcTable.Data(newoj,data$profession)
TValueTable.Data(newoj,data$profession)
